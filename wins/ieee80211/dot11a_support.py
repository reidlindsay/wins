#!  /usr/bin/env python

"""
Packet definitions, enumerations, and helper functions for IEEE 802.11a physical
layer protocol.

Revision Info
=============
* $LastChangedBy: mandke $
* $LastChangedDate: 2011-09-27 22:15:57 -0500 (Tue, 27 Sep 2011) $
* $LastChangedRevision: 5167 $

:author: Ketan Mandke <kmandke@mail.utexas.edu>

:copyright:
    Copyright 2009 The University of Texas at Austin

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

:var DOT11A_USEPARITY:
    Boolean flag; if true, use parity check parameter in `Dot11A`.

:var DOT11A_USE_PIECEWISE_PER:
    Boolean flag; if true, use SINR heap to calculate PER in piecewise fashion.

:var DOT11A_VERBOSE:
    Constant enumeration to control verbose thresholds in this file.
  
    Setting the verbose level of a `Dot11APHY` above this threshold will cause
    the corresponding output in this class to be written (or logged).

:var DOT11A_NBPSC: Number of coded bits per subcarrier.

:var DOT11A_NDBPS: Number of data bits per OFDM symbol.

:var DOT11A_MTYPE: Modulation type enumeration for M-QAM constellations.

:var DOT11A_CODERATE:
    Punctured convolution code rate used for forward error correction (contains
    string representation of ratio).

:var DOT11A_DATARATE:
    Effective data rate in bits-per-second (bps) for OFDM payload of waveform
    generated by IEEE 802.11a physical layer; does not account for training
    overhead.

:var DOT11A_TFFT: Duration of FFT Period.

:var DOT11A_TGI: Duration of guard interval (GI).

:var DOT11A_TSYM: Duration of an OFDM symbol (TFFT+TGI).

:var DOT11A_TSHORT: Short training sequence duration.

:var DOT11A_TLONG: Long training sequence duration.

:var DOT11A_TSIGNAL: Duration of SIGNAL OFDM symbol.

:var DOT11A_TDETECT: Duration allowed for packet detection.

:var DOT11A_MAXPOWER: Maximum transmit power (in dBm).

:var DOT11A_NOISEFIGURE: Noise factor due to digital impairments (in dB).

:var DOT11A_ANALOGLOSS: Loss factor associated with analog impairments (in dB).

:var DOT11A_SYSTEMLOSS: NOISEFIGURE x ANALOGLOSS (in dB).

:var DOT11A_CARRIER: Carrier frequency (in Hz).

:var DOT11A_BANDWIDTH: System bandwidth (in Hz).

:var DOT11A_RXSENSITIVITY:
    Minimum receiver power (in dBm) to achieve a packet error rate less than 10%
    for a PSDU of length 1000 bytes, using the base rate (i.e. BPSK, 1/2 coding).

:var DOT11A_CSTHRESHOLD:
    Carrier sense threshold (in dBm); receive power threshold above which a
    carrier sense busy should automatically be assessed.

:var DOT11A_FDTHRESHOLD:
    Frame detection threshold (in dB); during frame detection, the
    signal-to-interference-and-noise ratio (SINR) must exceed this value in
    order for the packet detector to find an incoming frame.
"""
__docformat__ = "restructuredtext en"

from scapy.all import Packet, BitField, ActionField
from numpy import inf

DOT11A_USEPARITY = 0
DOT11A_USE_PIECEWISE_PER = 1

DOT11A_VERBOSE  = 63
DOT11A_NBPSC    = [     1,     1,     2,     2,      4,      4,      6,      6]
DOT11A_NDBPS    = [    24,    36,    48,    72,     96,    144,    192,    216]
DOT11A_MTYPE    = ["BPSK","BPSK","QPSK","QPSK","16QAM","16QAM","64QAM","64QAM"]
DOT11A_CODERATE = [ "1/2", "3/4", "1/2", "3/4",  "1/2",  "3/4",  "2/3",  "3/4"]
DOT11A_DATARATE = [   6e6,   9e6,  12e6,  18e6,   24e6,   36e6,   48e6,   54e6]

DOT11A_TFFT    = 3.2e-6
DOT11A_TGI     = 0.8e-6
DOT11A_TSYM    = 4.0e-6
DOT11A_TSHORT  = 8.0e-6
DOT11A_TLONG   = 8.0e-6
DOT11A_TSIGNAL = 4.0e-6
DOT11A_TDETECT = 4.0e-6

DOT11A_MAXPOWER = 16.02
DOT11A_NOISEFIGURE = 10.0
DOT11A_ANALOGLOSS = 5.0
DOT11A_SYSTEMLOSS = DOT11A_ANALOGLOSS + DOT11A_NOISEFIGURE
DOT11A_CARRIER    = 5.25e9
DOT11A_BANDWIDTH  = 20e6

DOT11A_RXSENSITIVITY = -82
DOT11A_CSTHRESHOLD   = -62
##  FIXME: No standard value for detection threshold
#DOT11A_FDTHRESHOLD   = -inf     # all packets are detected
DOT11A_FDTHRESHOLD   = 0.0      # SINR threshold

class Dot11A(Packet):
    """Packet format for IEEE 802.11a physical layer packet header.

    This class inherits from the `Dot11` class from Scapy. All the fields will
    be encoded as part of the SIGNAL field in the IEEE 802.11a packet.

       4      1       12       1       6
    ----------------------------------------
    | rate | rsvd | length | parity | tail |
    ----------------------------------------
    """
    name = "802.11A PHY"
    fields_desc = [ActionField(BitField('rate', 0, 4), \
                                        'updatepar', param='rate'), \
                   ActionField(BitField('reserved', 0, 1), \
                                        'updatepar', param='reserved'), \
                   ActionField(BitField('length', 0, 12), \
                                        'updatepar', param='length'),  \
                   BitField('parity', 0, 1), \
                   ActionField(BitField('tail', 0, 6), \
                                        'updatepar', param='tail') ]
    def updatepar(self, val, fld, param=None, **kwargs):
        """Update parity check value."""
        if not DOT11A_USEPARITY: return
        rate, reserved = self.rate, self.reserved
        length, tail   = self.length, self.tail
        if (param=="rate"): rate = val
        if (param=="reserved"): reserved = val
        if (param=="length"): length = val
        if (param=="tail"): tail = val
        chksum = rate+reserved+length+tail
        self.parity = (chksum%2)

    def checkpar(self):
        """Check parity of checksum."""
        if not DOT11A_USEPARITY: return True
        chksum = self.rate+self.reserved+self.length+self.tail
        return (self.parity==(chksum%2) )

def isdot11a(p):
    """Is packet an IEEE 802.11a packet?"""
    isdot11a = isinstance(p, Packet) and p.haslayer(Dot11A)
    return isdot11a

def get_dot11a(p):
    """Extract IEEE 802.11a physical layer packet form `p`.

    :return: IEEE 802.11a packet or `None` if no matching layer found.
    """
    dot11a = None
    if isdot11a(p):
        dot11a = p[Dot11A]
    return dot11a
