#!  /usr/bin/env python

"""
Packet definitions, enumerations, and helper functions for IEEE 802.11n physical
layer protocol.

Revision Info
=============
* $LastChangedBy: mandke $
* $LastChangedDate: 2011-09-27 22:15:57 -0500 (Tue, 27 Sep 2011) $
* $LastChangedRevision: 5167 $

:author: Ketan Mandke <kmandke@mail.utexas.edu>

:copyright:
    Copyright 2009 The University of Texas at Austin

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

:var DOT11N_USE_SIGNALCRC:
    Boolean flag; if true, use 'crc' parameter in `Dot11N` for 8-bit checksum in
    packet SIGNAL field.

:var DOT11N_USE_PIECEWISE_PER:
    Boolean flag; if true, use SINR heap to calculate PER in piecewise fashion.

:var DOT11N_SINR_METHOD:
    String specifying what method of SINR computation will be used in the
    function `Dot11NPHY.sinr()` (see this function for more).

:var DOT11N_USE_SOVA:
    Boolean flag; if true, use soft-decision decoding (i.e. Soft-Output Viterbi
    Algorithm) when calculating PER. This effectively applies an additional
    coding gain over hard-decision decoding.

:var DOT11N_USE_RFO:
    Boolean flag; if true, include residual frequency offset as part of model
    for calculating PER.

:var DOT11N_MAXINPUT:
    Maximum number of samples allowed in PHY input buffer.

:var DOT11N_WAVEFORM_PAD:
    Number of samples to append/prepend to waveforms received by the PHY.

:var DOT11N_VERBOSE:
    Constant enumeration to control verbose thresholds in this file.
  
    Setting the verbose level of a `Dot11NPHY` above this threshold will cause
    the corresponding output in this class to be written (or logged).

:var DOT11N_NFFT: FFT size.

:var DOT11N_NSD: Number of data subcarriers.

:var DOT11N_NSP: Number of pilot subcarriers.

:var DOT11N_NSS: Number of spatial streams.

:var DOT11N_NBPSC: Number of coded bits per subcarrier.

:var DOT11N_NDBPS: Number of data bits per OFDM symbol.

:var DOT11N_MTYPE: Modulation type enumeration for M-QAM constellations.

:var DOT11N_CODERATE:
    Punctured convolution code rate used for forward error correction (contains
    string representation of ratio).

:var DOT11N_DATARATE:
    Effective data rate in bits-per-second (bps) for OFDM payload of waveform
    generated by IEEE 802.11n physical layer; does not account for training
    overhead.

:var DOT11N_TFFT: Duration of FFT Period.

:var DOT11N_TGI: Duration of guard interval (GI).

:var DOT11N_TSYM: Duration of an OFDM symbol (TFFT+TGI).

:var DOT11N_TSHORT: Short training sequence duration.

:var DOT11N_TLONG: Long training sequence duration.

:var DOT11N_TSIGNAL: Duration of HT-SIGNAL OFDM symbols.

:var DOT11N_TDETECT: Duration allowed for packet detection.

:var DOT11N_MAXPOWER: Maximum transmit power (in dBm).

:var DOT11N_NOISEFIGURE: Noise factor due to digital impairments (in dB).

:var DOT11N_ANALOGLOSS: Loss factor associated with analog impairments (in dB).

:var DOT11N_SYSTEMLOSS: NOISEFIGURE x ANALOGLOSS (in dB).

:var DOT11N_CARRIER: Carrier frequency (in Hz).

:var DOT11N_CARRIER_CH1: Carrier frequency for Channel 1 in the 2.4 GHz band.

:var DOT11N_CARRIER_CH6: Carrier frequency for Channel 6 in the 2.4 GHz band.

:var DOT11N_CARRIER_CH11: Carrier frequency for Channel 11 in the 2.4 GHz band.

:var DOT11N_CARRIER_CH36: Carrier frequency for Channel 36 in the 5 GHz band.

:var DOT11N_CARRIER_CH52: Carrier frequency for Channel 52 in the 5 GHz band.

:var DOT11N_CARRIER_CH149: Carrier frequency for Channel 149 in the 5 GHz band.

:var DOT11N_BANDWIDTH: System bandwidth (in Hz).

:var DOT11N_RXSENSITIVITY:
    Minimum receiver power (in dBm) to achieve a packet error rate less than 10%
    for a PSDU of length 1000 bytes, using the base rate (i.e. BPSK, 1/2 coding).

:var DOT11N_CSTHRESHOLD:
    Carrier sense threshold (in dBm); receive power threshold above which a
    carrier sense busy should automatically be assessed.

:var DOT11N_FDTHRESHOLD0:
    Minimum frame detection threshold (in dB); during frame detection, if the
    signal-to-interference-and-noise ratio (SINR) is below this threshold, then
    the packet detector will not find the incoming frame.

:var DOT11N_FDTHRESHOLD1:
    Maximum frame detection threshold (in dB); during frame detection, if the
    signal-to-interference-and-noise ratio (SINR) exceeds this value, then the
    packet detector will always find detect the incoming frame.

:var DOT11N_STF:
    Bit mask used to represent short training field.

:var DOT11N_LTF:
    Bit mask used to represent long training field.

:var DOT11N_SIGNAL:
    Bit mask used to represent PHY header (i.e. SIGNAL field).

:var DOT11N_PAYLOAD:
    Bit mask used to represent PHY payload.
"""
__docformat__ = "restructuredtext en"

from scapy.all import Packet, BitField, ActionField
from scapy.all import BitEnumField
from numpy import inf

from wins.backend.crc import CRC

DOT11N_USE_SIGNALCRC = 1
DOT11N_USE_PIECEWISE_PER = 1
DOT11N_SINR_METHOD = 'piecewise'
DOT11N_USE_RFO = 0
DOT11N_USE_SOVA = 0
DOT11N_MAXINPUT = 100000
DOT11N_WAVEFORM_PAD = 50

DOT11N_VERBOSE  = 64
DOT11N_NFFT     = 64
DOT11N_NSD      = 52
DOT11N_NSP      = 4
DOT11N_NSS      = [     1,      1,      1,       1,       1,       1,       1,       1,     2,     2,      2,      2,      2,      2,      2,      2,      3,     3,      3,      3,      3,      3,       3,      3,     4,     4,      4,      4,      4,      4,      4,      4,]
DOT11N_NBPSC    = [     1,      1,      2,       2,       4,       4,       6,       6,     1,     1,      2,      2,      4,      4,      6,      6,      1,     1,      2,      2,      4,      4,       6,      6,     1,     1,      2,      2,      4,      4,      6,      6,]
DOT11N_NDBPS    = [    26,     52,     78,     104,     156,     208,     234,     260,    52,   104,    156,    208,    312,    416,    468,    520,     78,   156,    234,    312,    468,    624,     702,    780,   104,   208,    312,    416,    624,    832,    936,   1040,]
DOT11N_MTYPE    = ["BPSK", "QPSK", "QPSK", "16QAM", "16QAM", "64QAM", "64QAM", "64QAM","BPSK","QPSK", "QPSK","16QAM","16QAM","64QAM","64QAM","64QAM", "BPSK","QPSK", "QPSK","16QAM","16QAM","64QAM", "64QAM","64QAM","BPSK","QPSK", "QPSK","16QAM","16QAM","64QAM","64QAM","64QAM",]
DOT11N_CODERATE = [ "1/2",  "1/2",  "3/4",   "1/2",   "3/4",   "2/3",   "3/4",   "5/6", "1/2", "1/2",  "3/4",  "1/2",  "3/4",  "2/3",  "3/4",  "5/6",  "1/2", "1/2",  "3/4",  "1/2",  "3/4",  "2/3",   "3/4",  "5/6", "1/2", "1/2",  "3/4",  "1/2",  "3/4",  "2/3",  "3/4",  "5/6",]
#DOT11N_DATARATE = [ 6.5e6,  13e6, 19.5e6,   26e6,   39e6,   52e6, 58.5e6,   65e6,  13e6,  26e6,   39e6,   52e6,   78e6,  104e6,  117e6,  130e6, 19.5e6,  39e6, 58.5e6,   78e6,  117e6,  156e6, 175.5e6,  195e6,  26e6,  52e6,   78e6,  104e6,  156e6,  208e6,  234e6,  260e6,]

def get_dot11n_datarate(idx):
    """Get Data Rate corresponding to MCS index."""
    if (idx<0) or (idx+1>len(DOT11N_NDBPS)):
        raise IndexError
    ndbps = DOT11N_NDBPS[idx]
    tsym  = DOT11N_TSYM
    # calculate rate
    rate = ndbps/tsym
    return rate

def get_dot11n_datarate_len():
    """Get number of MCS options."""
    return len(DOT11N_NDBPS)

class _GetDataRateType(type):
    __getitem__ = staticmethod(get_dot11n_datarate)
    __len__ = staticmethod(get_dot11n_datarate_len)

class DOT11N_DATARATE(object):
    """Meta class to enable access to `get_dot11n_datarate` using index operator."""
    __metaclass__ = _GetDataRateType
    __getitem__ = staticmethod(get_dot11n_datarate)
    __len__ = staticmethod(get_dot11n_datarate_len)

DOT11N_TFFT    = 3.2e-6
DOT11N_TGI     = 0.8e-6
DOT11N_TSYM    = 4.0e-6
DOT11N_TSHORT  = 8.0e-6
DOT11N_TLONG   = 8.0e-6
DOT11N_TSIGNAL = 8.0e-6
DOT11N_TDETECT = 4.0e-6

DOT11N_MAXPOWER = 16.02
DOT11N_NOISEFIGURE = 10.0
DOT11N_ANALOGLOSS = 5.0
DOT11N_SYSTEMLOSS = DOT11N_ANALOGLOSS + DOT11N_NOISEFIGURE
DOT11N_CARRIER_CH1   = 2.412e9       # 2.4 GHz band
DOT11N_CARRIER_CH6   = 2.437e9
DOT11N_CARRIER_CH11  = 2.462e9
DOT11N_CARRIER_CH36  = 5.180e9       # 5 GHz band
DOT11N_CARRIER_CH52  = 5.260e9
DOT11N_CARRIER_CH149 = 5.745e9
DOT11N_CARRIER       = DOT11N_CARRIER_CH36
DOT11N_BANDWIDTH  = 20e6

DOT11N_RXSENSITIVITY = -82
DOT11N_CSTHRESHOLD   = -62
##  FIXME: No standard value for detection threshold
#DOT11N_FDTHRESHOLD   = -inf     # all packets are detected
DOT11N_FDTHRESHOLD0  = 1.5      # drop all packets below this SINR threshold
DOT11N_FDTHRESHOLD1  = 5.0      # detect all packets below this SINR threshold


DOT11N_STF = 1<<0
DOT11N_LTF = 1<<1
DOT11N_SIGNAL  = 1<<2
DOT11N_PAYLOAD = 1<<3

class Dot11N(Packet):
    """Packet format for IEEE 802.11n physical layer packet header.

    This class inherits from the `Dot11` class from Scapy. All the fields will
    be encoded as part of the SIGNAL field in the IEEE 802.11n packet.

       4      1       12       1       6
    ----------------------------------------
    | rate | rsvd | length | crc | tail |
    ----------------------------------------
    """
    name = "802.11N PHY"
    fields_desc = [BitField('rate', 0, 7), \
                   BitEnumField('bw', 0, 1, {0:'20 MHz', 1: '40 MHz'} ), \
                   BitField('length', 0, 16), \
                   BitField('smoothing', 0, 1), \
                   BitEnumField('notsounding', 1, 1, {0: 'SOUDNING', 1: 'NOT SOUNDING'} ), \
                   BitField('reserved', 1, 1), \
                   BitField('aggregation', 0, 1), \
                   BitField('stbc', 0, 2), \
                   BitField('ldpc', 0, 1), \
                   BitField('shortgi', 0, 1), \
                   BitField('ness', 0, 2), \
                   BitField('crc', 0, 8), \
                   BitField('tail', 0, 6) ]
    def updatecrc(self):
        """Update crc checksum value."""
        if not DOT11N_USE_SIGNALCRC: return
        s = str(self)
        crc_coder = CRC("ATM-8")
        self.crc = crc_coder.parity(s[0:5], 34)

    def checkcrc(self):
        """Check cyclic-redundancy check."""
        if not DOT11N_USE_SIGNALCRC: return True
        s = str(self)
        crc_coder = CRC("ATM-8")
        chksum = crc_coder.parity(s[0:5], 34)
        return (self.crc==chksum)

def isdot11n(p):
    """Is packet an IEEE 802.11n packet?"""
    isdot11n = isinstance(p, Packet) and p.haslayer(Dot11N)
    return isdot11n

def get_dot11n(p):
    """Extract IEEE 802.11n physical layer packet form p.

    :return: IEEE 802.11n packet or `None` if no matching layer found.
    """
    dot11n = None
    if isdot11n(p):
        dot11n = p[Dot11N]
    return dot11n
